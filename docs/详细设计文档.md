# 影院管理系统（CMS）软件详细设计文档

## 文档修改历史

| 修改人员 |   日期    |      修改原因      |   版本号   |
| :------: | :-------: | :----------------: | :--------: |
| Agent_67 | 2019.5.25 | 初始化 | v0.0 |
| Agent_67 | 2019.6.2 | 第一次整合 | v1.0 |
| Agent_67 | 2019.6.17 | 加入类设计图和顺序图 | v2.0 |

## 1. 引言

### 1.1 编制目的

本报告详细完成对连续商店管理系统的详细设计，达到指导后续软件构造的目的，同时实现和测试人员及用户的沟通。

本报告面向开发人员、测试人员及最终用户而编写，是了解系统的导航。

### 1.2 词汇表

| 词汇名称 | 词汇含义 | 备注 |
| :-: | :-: | :-: |
| CMS | 影院管理系统 | Cinema Management System |

### 1.3 参考资料

1. IEEE标准。
2. 影院管理系统用例文档。
3. 影院管理系统需求规格说明文档。
4. 影院管理系统体系结构文档。
5. 骆斌，丁二玉，刘钦 - 软件工程与计算 . 卷二 , 软件开发的技术基础 : Software engineering and computing . Volume Ⅱ , Fundamentals of software development technology。

## 2. 产品描述

参考影院管理系统用例文档和影院管理系统需求规格说明文档中对产品的概括描述。

## 3. 系统结构设计概述

参考影院管理系统体系结构文档中对体系结构设计的描述。

## 4. 结构视角

### 4.1 业务逻辑层的分解

业务逻辑层的开发包图参见软件体系结构文档图2。

#### 4.1.1 userbl模块

(1) 模块概述

userbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

userbl模块的职责及接口参见软件体系结构文档表10。

(2) 整体结构

根据体系结构的设计，我们将系统分为展示层、控制层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如业务逻辑层和数据层之间，我们添加userdataservice.UserDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了控制层的UserController，这样UserController会将对用户登录注册登出的逻辑处理委托给UserBL。

userbl模块的设计如图1所示。

![](https://i.loli.net/2019/06/17/5d077c0411ea515024.png)

<div style="text-align: center">图1 userbl模块各个类的设计</div>

userbl模块各个类的职责如表1所示。

<div style="text-align: center">表1 userbl模块各个类的职责</div>

|  模块  |              职责              |
| :----: | :----------------------------: |
| AccountService | 负责实现用户登录注册登出的服务 |
| RoleService | 负责实现影院角色的添加修改删除的服务 |

(3) 模块内部类的接口规范

AccountService的接口规范如表2所示。

<div>
    <table>
        <caption><strong>表2 AccountService模块的接口规范</strong><caption>
        <hr/>
        <caption><strong>提供的服务（供接口）</strong><caption>
        <tr>
            <td rowspan="4"> AccountService.login </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public User login(UserForm userForm)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>userName符合输入条件</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据username查找是否存在相应的User，如果username和password相匹配，则建立session会话，最后返回登录验证的结果</td>
        </tr>
        <tr>
            <td rowspan="4"> AccountService.registerAccount </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO registerAccount(UserForm userForm)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>userFrom符合输入条件</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据UserForm查找是否已经存在对应的username，如果没有，则增加一条新的用户账号记录，最后返回注册的结果</td>
        </tr>
        <tr>
            <td rowspan="4"> AccountService.checkPassword </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO checkPassword(User user, String rawPassword)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>rawPassword符合输入条件</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据用户输入的密码返回验证结果</td>
        </tr>
        <tr>
            <td rowspan="4"> AccountService.editPassword </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO editPassword(UserForm userForm)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>用户账号存在</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据userForm查找用户的账号并修改账号密码，返回修改的结果</td>
        </tr>
    </table>
<div>

<div>
    <table>
        <caption><strong>需要的服务（需接口）</strong></caption>
        <tr>
            <td><strong>服务名</strong></td>
            <td><strong>服务</strong></td>
        </tr>
        <tr>
            <td>AccountMapper.createNewAccount(String username, String password, Integer auth)</td>
            <td>注册账号</td>
        </tr>
        <tr>
            <td>AccountMapper.getAccountByName( String username)</td>
            <td>根据用户名查找账号</td>
        </tr>
        <tr>
            <td>AccountMapper.updatePassword(UserForm userForm)</td>
            <td>修改密码</td>
        </tr>
    </table>
</div>

RoleService的接口规范如表3所示。

<div>
    <table>
        <caption><strong>表3 RoleService模块的接口规范</strong><caption>
        <hr/>
        <caption><strong>提供的服务（供接口）</strong><caption>
        <tr>
            <td rowspan="4"> RoleService.getAdaptableRoles </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO getAdaptableRoles(Integer level)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>输入的等级是有效等级</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>如果等级是有效的，根据等级查找并返回该等级可修改的影院角色</td>
        </tr>
        <tr>
            <td rowspan="4"> RoleService.deleteRole </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO deleteRole(Integer id)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>id符合输入条件</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>如果该id是有效的，根据id查找并删除该影院角色，返回删除结果</td>
        </tr>
        <tr>
            <td rowspan="4"> RoleService.editRole </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO editRole(RoleVO form)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>from符合输入条件</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>修改影院角色并返回修改结果</td>
        </tr>
        <tr>
            <td rowspan="4"> RoleService.addRole </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO addRole(RoleVO form)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>from符合输入条件</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据from添加影院角色，并返回添加结果</td>
        </tr>
    </table>
<div>

<div>
    <table>
        <caption><strong>需要的服务（需接口）</strong></caption>
        <tr>
            <td><strong>服务名</strong></td>
            <td><strong>服务</strong></td>
        </tr>
        <tr>
            <td>AccountMapper.getCinemaRoles()</td>
            <td>获取全部影院角色</td>
        </tr>
        <tr>
            <td>AccountMapper.deleteRoleById(Integer id)</td>
            <td>删除影院角色</td>
        </tr>
        <tr>
            <td>AccountMapper.updateRoleById(Integer id, String username,
                       String password, Integer auth)</td>
            <td>更新角色信息</td>
        </tr>
    </table>
</div>

(4) 业务逻辑层的动态模型

图1~4是影院管理系统中UserBL进行业务逻辑处理时的顺序图。
![](https://i.loli.net/2019/06/17/5d077c9c1933577026.png)
![](https://i.loli.net/2019/06/17/5d077c9c27ef317119.png)
![](https://i.loli.net/2019/06/17/5d077c9cf102c17894.png)
![](https://i.loli.net/2019/06/17/5d077c9ce6b3495822.png)

由于UserBL只作为工具进行业务逻辑处理，不持有成员变量，因而在处理过程中是无状态的。

(5) 业务逻辑层的设计原理

利用SpringBoot的依赖注入，通过数据层接口获得po后，进行业务逻辑处理，最后封装成ResponseVO返回给上层。



#### 4.1.2 salesbl模块

(1) 模块概述
salesbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

salesbl模块的职责及接口参见软件体系结构文档表24。

(2) 整体结构

根据体系结构的设计，我们将系统分为展示层、控制层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如业务逻辑层和数据层之间，我们添加salesdataservice.SalesDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了控制层的SalesController，这样SalesController会将操作优惠活动相关的逻辑处理委托给SalesBL。

salesbl模块的设计如图3所示。

![](https://i.loli.net/2019/06/17/5d077cddc830714790.png)

<div style="text-align: center">图3 salesbl模块各个类的设计</div>

salesbl模块各个类的职责如表4所示。

<div style="text-align: center">表4 salesbl模块各个类的职责</div>

|  模块   |             职责             |
| :-----: | :--------------------------: |
| TicketService |    负责实现操作电影票的服务    |
|  RefundService  | 负责实现退票功能所需要的服务 |

(3) 模块内部类的接口规范
TicketService的接口规范如表5

<div> 
    <table>
        <caption><strong>表5 TicketService模块的接口规范</strong><caption>
        <hr/>
        <caption><strong>提供的服务（供接口）</strong><caption>
        <tr>
            <td rowspan="4"> TicketService.completeByVIPCard </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO completeByVIPCard(List<Integer> id, int couponId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>id不为空</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据ticket查找是否存在相应的会员卡，根据couponId查找是否存在相应的优惠券，存在则完成购买电影票流程，返回购买结果</td>
        </tr>
        <tr>
            <td rowspan="4"> TicketService.addTicket </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO addTicket(TicketForm ticketForm)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>ticketFrom符合条件</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据ticketFrom锁座，返回锁座结果</td>
        </tr>
        <tr>
            <td rowspan="4"> TicketService.completeTicket </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO completeTicket(List<Integer> id, int couponId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>id不为空</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据ticketAndCouponVO查找并购买电影票，并返回购票结果</td>
        </tr>
        <tr>
            <td rowspan="4"> TicketService.getTicketByUser </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO getTicketByUser(int userId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>userId有效</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据userId查找并返回用户买过的电影票</td>
        </tr>
        <tr>
            <td rowspan="4"> TicketService.getBySchedule </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO getBySchedule(int scheduleId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>scheduleId是有效id</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据scheduleId查找并返回该排片的锁座情况</td>
        </tr>
        <tr>
            <td rowspan="4"> TicketService.cancelTicket </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO cancelTicket(List<Integer> id)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>id不为空</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据ticketId查找并删除电影票，返回删除结果</td>
        </tr>
        <tr>
            <td rowspan="4"> TicketService.issueTicket </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO issueTicket(int id)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>id为有效电影票id</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据ticketId查找并修改电影票状态为出票，返回出票结果</td>
        </tr>
    </table>
<div>

<div>
    <table>
        <caption><strong>需要的服务（需接口）</strong></caption>
        <tr>
            <td><strong>服务名</strong></td>
            <td><strong>服务</strong></td>
        </tr>
        <tr>
            <td>TicketMapper.insertTicket(Ticket ticket)</td>
            <td>添加单张电影票</td>
        </tr>
        <tr>
            <td>TicketMapper.insertTickets(List<Ticket> tickets)</td>
            <td>添加多张电影票</td>
        </tr>
        <tr>
            <td>TicketMapper.deleteTicket(int ticketId)</td>
            <td>删除电影票</td>
        </tr>
        <tr>
            <td>TicketMapper.selectTicketByUser(int userId)</td>
            <td>获得用户买过的票</td>
        </tr>
        <tr>
            <td>TicketMapper.deleteLockedTicket(int userId, int scheduleId)</td>
            <td>删除被锁座位的票</td>
        </tr>
        <tr>
            <td>TicketMapper.updateTicketState(int ticketId, int state)</td>
            <td>更新电影票状态</td>
        </tr>
        <tr>
            <td>TicketMapper.updateTicketActualPay(int ticketId, double actualPay)</td>
            <td>更新票的实际支付金额</td>
        </tr>
        <tr>
            <td>TicketMapper.selectTicketsBySchedule(int scheduleId)</td>
            <td>根据排片获取电影票</td>
        </tr>
        <tr>
            <td>TicketMapper.selectTicketByScheduleIdAndSeatint scheduleId, int columnIndex, int rowIndex)</td>
            <td>根据排片和座位获取电影票</td>
        </tr>
        <tr>
            <td>TicketMapper.selectTicketById(int id)</td>
            <td>根据id获取电影票</td>
        </tr>
        <tr>
            <td>ConsumeService.addConsumeHistory(Integer userId, Double money, Double discount, String consumeType, Integer type, Integer contentId)</td>
            <td>添加消费记录</td>
        </tr>
        <tr>
            <td>ScheduleServiceForBl.getScheduleItemById(int id)</td>
            <td>根据id查找排片信息</td>
        </tr>
        <tr>
            <td>HallServiceForBl.getHallById(int id)</td>
            <td>根据id查找影厅</td>
        </tr>
        <tr>
            <td>CouponServiceForBl.getCoupon(int couponId)</td>
            <td>根据id获取优惠券</td>
        </tr>
        <tr>
            <td>CouponServiceForBl.issueCoupon(int couponId,int userId)</td>
            <td>根据userId和couponId新增一条优惠券信息</td>
        </tr>
        <tr>
            <td>CouponServiceForBl.getCouponsByUser(int userId)</td>
            <td>根据userId获取优惠券</td>
        </tr>
        <tr>
            <td>ActivityServiceForBl.getActivitiesByMovie(int movieId)</td>
            <td>根据movieId获取优惠活动</td>
        </tr>
        <tr>
            <td>ActivityServiceForBl.getActivityList()</td>
            <td>获取所有优惠活动</td>
        </tr>
        <tr>
            <td>VIPServiceForBl.getCardByUserId(int userId)</td>
            <td>根据userId获取会员卡</td>
        </tr>
        <tr>
            <td>VIPServiceForBl.payByCard(int id, double balance)</td>
            <td>使用会员卡支付</td>
        </tr>
        <tr>
            <td>RefundServiceForBl.getRefundByMovieId(int movieId)</td>
            <td>根据movieId获取退票策略</td>
        </tr>
    </table>
</div>

RefundService的接口规范如表5

<div>
    <table>
        <caption><strong>表5 RefundService模块的接口规范</strong><caption>
        <hr/>
        <caption><strong>提供的服务（供接口）</strong><caption>
        <tr>
            <td rowspan="4"> RefundService.getAllRefund </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO getAllRefund()</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>获取并返回所有退票策略</td>
        </tr>
        <tr>
            <td rowspan="4"> RefundService.publishRefund </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO publishRefund(RefundForm refundForm)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>refundFrom符合输入条件</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据refundFrom新增一条退票策略，返回新增结果</td>
        </tr>
        <tr>
            <td rowspan="4"> RefundService.deleteRefund </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO deleteRefund(int refundId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>refundId存在</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据refundId查找并删除退票策略，返回删除结果</td>
        </tr>
        <tr>
            <td rowspan="4"> RefundService.getRefundById </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO getRefundById(int refundId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>refundId存在</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据refundId查找并返回退票策略</td>
        </tr>
    </table>
<div>

<div>
    <table>
        <caption><strong>需要的服务（需接口）</strong></caption>
        <tr>
            <td><strong>服务名</strong></td>
            <td><strong>服务</strong></td>
        </tr>
            <td>RefundMapper.selectRefund()</td>
            <td>获得所有退票策略</td>
        </tr>
        <tr>
            <td>RefundMapper.insertRefund(Refund refund)</td>
            <td>新增退票策略</td>
        </tr>
        <tr>
            <td>RefundMapper.deleteRefundById(int refundId)</td>
            <td>根据id删除一条退票策略</td>
        </tr>
        <tr>
            <td>RefundMapper.selectRefundByMovieId(int movieId)</td>
            <td>根据电影获取退票策略</td>
        </tr>
        <tr>
            <td>RefundMapper.selectRefundById(int refundId)</td>
            <td>根据id获取退票策略</td>
        </tr>
        <tr>
            <td>MovieServiceForBl.getMovieById(int id)</td>
            <td>根据id查找电影</td>
        </tr>
    </table>
</div>

(4) 业务逻辑层的动态模型
图5~8是影院管理系统中SalesBL进行业务逻辑处理时的顺序图。

![](https://i.loli.net/2019/06/17/5d077d23024a596351.png)
![](https://i.loli.net/2019/06/17/5d077d2408cbd50170.png)
![](https://i.loli.net/2019/06/17/5d077d23ee81c75581.png)
![](https://i.loli.net/2019/06/17/5d077d245c8b741751.png)

由于SalesBL只作为工具进行业务逻辑处理，不持有成员变量，因而在处理过程中是无状态的。

(5) 业务逻辑层的设计原理

利用SpringBoot的依赖注入，通过数据层接口获得po后，进行业务逻辑处理，最后封装成ResponseVO返回给上层。

#### 4.1.3 statisticsbl模块

(1)模块概述

statisticsbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

statisticsbl模块的职责及接口参见软件体系结构文档表Y。

(2) 整体结构

根据体系结构的设计，我们将系统分为展示层、控制层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如业务逻辑层和数据层之间，我们添加statisticsdataservice.MovieLikeDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了控制层的StatisticsController，这样StatisticsController会将电影统计数据相关的逻辑处理委托给MovieLikeBL和StatisticsBL。

statisticsbl模块的设计如图9所示。

![](https://s2.ax1x.com/2019/06/17/VHxnvq.png)

<div style="text-align: center">图9 statisticsbl模块各个类的设计</div>

statisticsbl模块各个类的职责如表6所示。

<div style="text-align: center">表6 statisticsbl模块各个类的职责</div>

|     模块     |                 职责                 |
| :----------: | :----------------------------------: |
| MovieLikeBL  |      负责实现想看电影相关的服务      |
| StatisticsBL | 负责实现获取电影统计数据所需要的服务 |

(3) 模块内部类的接口规范

MovieLikeBL和StatisticsBL的接口规范如表7~8所示。

<div>
    <table>
        <caption><strong>表7 MovieLikeBL模块的接口规范</strong><caption>
        <hr/>
        <caption><strong>提供的服务（供接口）</strong><caption>
        <tr>
            <td rowspan="4">MovieLikeBL.likeMovie</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>ResponseVO likeMovie(int userId, int movieId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>标记电影为想看</td>
        </tr>
        <tr>
            <td rowspan="4">MovieLikeBL.unLikeMovie</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>ResponseVO unlikeMovie(int userId, int movieId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>取消电影为想看</td>
        </tr>
        <tr>
            <td rowspan="4">MovieLikeBL.getCountOfLikes</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>ResponseVO getCountOfLikes(int movieId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>统计想看电影的人数</td>
        </tr>
        <tr>
            <td rowspan="4">MovieLikeBL.getLikeNumsGroupByDate</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>ResponseVO getLikeNumsGroupByDate(int movieId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>获得电影每日的想看人数</td>
        </tr>
    </table>
<div>


<div>
    <table>
        <caption><strong>需要的服务（需接口）</strong></caption>
        <tr>
            <td><strong>服务名</strong></td>
            <td><strong>服务</strong></td>
        </tr>
        <tr>
            <td>MovieLikeDataService.insertOneLike(int movieId,int userId)</td>
            <td>插入一条想看记录</td>
        </tr>
        <tr>
        	<td>MovieLikeDataService.deleteOneLike(int movieId,int userId)</td>
            <td>删除一条想看记录</td>
        </tr>
         <tr>
        	<td>MovieLikeDataService.selectLikeNums(int movieId)</td>
            <td>根据movieId查看电影的想看人数</td>
        </tr>
         <tr>
        	<td>MovieLikeDataService.selectLikeMovie(int movieId,int userId)</td>
            <td>根据movieId和userId查找特定想看记录</td>
        </tr>
         <tr>
        	<td>MovieLikeDataService.selectMovieScheduleTimes(Date date, Date nextDate)</td>
            <td>查询date当天每部电影的排片次数</td>
        </tr>
        <tr>
        	<td>MovieLikeDataService.getDateLikeNum(int movieId)</td>
            <td>根据movieId获取按日期统计的想看人数</td>
        </tr>
    </table>
</div>
<div>
    <table>
        <caption><strong>表8 StatisticsBL模块的接口规范</strong><caption>
        <hr/>
        <caption><strong>提供的服务（供接口）</strong><caption>
        <tr>
            <td rowspan="4">StatisticsBL.getScheduleRateByDate</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>ResponseVO getScheduleRateByDate(Date date)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>获取某日各影片排片率统计数据</td>
        </tr>
        <tr>
            <td rowspan="4">StatisticsBL.getTotalBoxOffice</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>ResponseVO getTotalBoxOffice()</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>获取所有电影的累计票房(降序排序，且包含已下架的电影)</td>
        </tr>
        <tr>
            <td rowspan="4">StatisticsBL.getAudiencePriceSevenDays</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>ResponseVO getAudiencePriceSevenDays()</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>获得过去7天内每天客单价</td>
        </tr>
        <tr>
            <td rowspan="4">StatisticsBL.getMoviePlacingRateByDate</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>ResponseVO getMoviePlacingRateByDate(Date date)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>获取所有电影某天的上座率</td>
        </tr>
        <tr>
            <td rowspan="4">StatisticsBL.getPopularMovies</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>ResponseVO getPopularMovies(int days, int movieNum)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>获取最近days天内，票房最高的的movieNum个电影</td>
        </tr>
    </table>
<div>


<div>
    <table>
        <caption><strong>需要的服务（需接口）</strong></caption>
        <tr>
            <td><strong>服务名</strong></td>
            <td><strong>服务</strong></td>
        </tr>
         <tr>
        	<td>StatisticsDataService.selectMovieScheduleTimes(Date date, Date nextDate)</td>
            <td>查询date当天每部电影的排片次数</td>
        </tr>
        <tr>
        	<td>StatisticsDataService.getDateLikeNum(int movieId)</td>
            <td>根据movieId获取按日期统计的想看人数</td>
        </tr>
        <tr>
        	<td>StatisticsDataService.selectMovieTotalBoxOffice()</td>
            <td>查询所有电影的总票房（包括已经下架的，降序排列）</td>
        </tr>
        <tr>
        	<td>StatisticsDataService.selectAudiencePrice(Date date,Date nextDate)</td>
            <td>查询date当天每个客户的购票金额</td>
        </tr>
        <tr>
        	<td>StatisticsDataService.selectPlacingRate(Date date,Date nextDate)</td>
            <td>查询date当天各电影上座率</td>
        </tr>
        <tr>
        	<td>StatisticsDataService.selectRecentTotalBoxOffice(Date startDate,Date today,int num)</td>
            <td>查询startDate到today日期内票房最高的num部电影</td>
        </tr>
    </table>
</div>

(4) 业务逻辑层的动态模型

图10是影院管理系统中StatisticsBL进行业务逻辑处理时的顺序图。

![](https://s2.ax1x.com/2019/06/17/VHx1VU.png)

由于MovieLikeBL和StatisticsBL只作为工具进行业务逻辑处理，不持有成员变量，因而在处理过程中是无状态的。

(5) 业务逻辑层的设计原理

利用SpringBoot的依赖注入，通过数据层接口获得po后，进行业务逻辑处理，将需要在页面上显示的信息封装成vo，最后封装成ResponseVO返回给上层。

#### 4.1.4 consumebl模块

(1)模块概述

consumebl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

consumebl模块的职责及接口参见软件体系结构文档表Y。

(2) 整体结构

根据体系结构的设计，我们将系统分为展示层、控制层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如业务逻辑层和数据层之间，我们添加consumedataservice.ConsumeDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了控制层的ConsumeController，这样ConsumeController会将电影统计数据相关的逻辑处理委托给ConsumeBL。

consumebl模块的设计如图11所示。

![](https://s2.ax1x.com/2019/06/17/VHxJPJ.png)

<div style="text-align: center">图11 consumebl模块各个类的设计</div>

consumebl模块各个类的职责如表9所示。

<div style="text-align: center">表9consumebl模块各个类的职责</div>

|   模块    |              职责              |
| :-------: | :----------------------------: |
| ConsumeBL | 负责实现充值消费记录相关的服务 |

(3) 模块内部类的接口规范

ConsumeBL的接口规范如表10所示。

<div>
    <table>
        <caption><strong>表10 ConsumeBL模块的接口规范</strong><caption>
        <hr/>
        <caption><strong>提供的服务（供接口）</strong><caption>
        <tr>
            <td rowspan="4">ConSumeBL.getAllTopUpHistory</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>ResponseVO getAllTopUpHistory(Integer userId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>获取用户全部的充值记录</td>
        </tr>
        <tr>
            <td rowspan="4">ConSumeBL.getBriefConsumeHis</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>ResponseVO getBriefConsumeHis(Integer userId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>获取用户简略消费记录信息</td>
        </tr>
        <tr>
            <td rowspan="4">ConSumeBL.getConsumeHisDetail</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>ResponseVO getConsumeHisDetail(Integer id)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>获取用户消费记录详细信息</td>
        </tr>
        <tr>
            <td rowspan="4">ConSumeBL.addTopUpHistory</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>ResponseVO addTopUpHistory(Integer userId, Double money, Double discount, Double balance, Timestamp time)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>添加充值记录</td>
        </tr>
        <tr>
            <td rowspan="4">ConSumeBL.addConsumeHistory</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>ResponseVO addConsumeHistory(Integer userId, Double money, Double discount, String consumeType,Integer type, Integer contentId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>添加消费记录</td>
        </tr>
        <tr>
            <td rowspan="4">ConSumeBL.getConsumeQualifiedUsers</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>ResponseVO getConsumeQualifiedUsers(Double totalConsume)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>获取消费总额满一定值的用户信息</td>
        </tr>
    </table>
<div>
<div>
    <table>
        <caption><strong>需要的服务（需接口）</strong></caption>
        <tr>
            <td><strong>服务名</strong></td>
            <td><strong>服务</strong></td>
        </tr>
        <tr>
            <td>ConsumeDateService.getTopUpHistoryByUserId(Integer userId)</td>
            <td>根据userId获取此用户的充值记录列表，若无记录则返回空</td>
        </tr>
        <tr>
        	<td>ConsumeDateService.getConsumeHistoryByUserId(Integer userId)</td>
            <td>根据userId获取此用户的消费记录列表，若无记录则返回空</td>
        </tr>
         <tr>
        	<td>ConsumeDateService.getConsumeHistoryById(Integer id)</td>
            <td>根据id获取消费记录</td>
        </tr>
         <tr>
        	<td>ConsumeDateService.insertTopUpHistory(Integer userId, Double money,Double discount,Double balance,Timestamp time)</td>
            <td>插入新的充值记录</td>
        </tr>
         <tr>
        	<td>ConsumeDateService.insertConsumeHistory(Integer userId, Double money,Double discount,String consumeType,Integer type,Integer contentId)</td>
            <td>插入新的消费记录</td>
        </tr>
        <tr>
        	<td>ConsumeDateService.selectConsumeQulifiedUsers(Double totalConsume)</td>
            <td>获得消费总额大于totalConsume的用户</td>
        </tr>
        <tr>
        	<td>HallServiceForBl.getHallById(int id)</td>
            <td>获得指定影厅信息</td>
        </tr>
        <tr>
        	<td>MovieServiceForBl.getMovieById(int id)</td>
            <td>获得指定电影信息</td>
        </tr>
        <tr>
        	<td>ScheduleServiceForBl.getScheduleItemById(int id)</td>
            <td>获得指定排片信息</td>
        </tr>
        <tr>
        	<td>VipService.getCardById(int id)</td>
            <td>获得指定会员卡信息</td>
        </tr>
        <tr>
        	<td>TicketServiceForBl.getTicketById(int id)</td>
            <td>获得指定电影票信息</td>
        </tr>
    </table>
</div>


(4) 业务逻辑层的动态模型

图12~14是影院管理系统中ConsumeBL进行业务逻辑处理时的顺序图。

![](https://s2.ax1x.com/2019/06/17/VHxNx1.png)

![](https://s2.ax1x.com/2019/06/17/VHxdr6.png)

![](https://s2.ax1x.com/2019/06/17/VHxDaD.png)

由于ConsumeBL只作为工具进行业务逻辑处理，不持有成员变量，因而在处理过程中是无状态的。

(5) 业务逻辑层的设计原理

利用SpringBoot的依赖注入，通过数据层接口获得po后，进行业务逻辑处理，将需要在页面上显示的信息封装成vo，最后封装成ResponseVO返回给上层。

#### 4.1.5 activitybl模块

(1) 模块概述

activitybl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

activitybl模块的职责及接口参见软件体系结构文档。

(2) 整体结构

根据体系结构的设计，我们将系统分为展示层、控制层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如业务逻辑层和数据层之间，我们添加activitydataservice.ActivityDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了控制层的ActivityController，这样ActivityController会将操作优惠活动相关的逻辑处理委托给ActivityBL。

activitybl模块的设计如图15所示。

![](https://s2.ax1x.com/2019/06/05/VNLPr8.png)

<div style="text-align: center">图15 activitybl模块各个类的设计</div>

activitybl模块各个类的职责如表11所示。

<div style="text-align: center">表11 activitybl模块各个类的职责</div>

|    模块    |            职责            |
| :--------: | :------------------------: |
| ActivityBL | 负责实现操作优惠活动的服务 |

(3) 模块内部类的接口规范

ActivityBL的接口规范如表12所示。

<div>
    <table>
        <caption><strong>表12 ActivityBL的接口规范</strong><caption>
        <hr/>
        <caption><strong>提供的服务（供接口）</strong></caption>
        <tr>
            <td rowspan="4">ActivityBL.publishActivity</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO publishActivity(ActivityForm activityForm)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>activityForm格式正确</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>发布一个优惠活动</td>
        </tr>
        <tr>
            <td rowspan="4">ActivityBL.getActivities</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO getActivities()</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>获取所有优惠活动信息</td>
        </tr>
            <td rowspan="4">ActivityBL.deleteActivity</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO deleteActivity(int activityId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>activityId格式正确</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>删除优惠活动</td>
        </tr>
        <tr>
            <td rowspan="4">ActivityBL.getActivityById</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO getActivityById(int activityId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>activityId格式正确</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>获取指定id的优惠活动</td>
        </tr>
    </table>
<div>
<div>
    <table>
        <caption><strong>需要的服务（需接口）</strong><caption>
        <tr>
            <td style="font-weight:bold">服务名</td>
            <td style="font-weight:bold">服务</td>
        </tr>
        <tr>
            <td>ActivityDataService.insertActivity(Activity activity)</td>
            <td>在数据库中插入一个优惠活动</td>
        </tr>
        <tr>
            <td>
                ActivityDataService.insertActivityAndMovie(int activityId,List&lt;Integer&gt; movieId)
            </td>
            <td>在数据库中插入一条活动和电影的关系</td>
        </tr>
        <tr>
            <td>ActivityDataService.selectActivities()</td>
            <td>返回所有优惠活动信息</td>
        </tr>
        <tr>
            <td>ActivityDataService.selectActivitiesByMovie(int movieId)</td>
            <td>返回特定电影的优惠活动信息</td>
        </tr>
        <tr>
            <td>ActivityDataService.selectById(int id)</td>
            <td>获取指定id的优惠活动</td>
        </tr>
        <tr>
            <td>ActivityDataService.deleteActivityById(int id)</td>
            <td>删除指定的优惠活动</td>
        </tr>
        <tr>
            <td>ActivityDataService.deleteActivityAndMovie(int id)</td>
            <td>根据活动id删除活动和电影关系</td>
        </tr>
    </table>
</div>
(4) 业务逻辑层的动态模型


图16~19是影院管理系统中ActivityBL进行业务逻辑处理时的顺序图。

![](https://s2.ax1x.com/2019/06/05/VNXwUe.png)

<div style="text-align: center">图16 发布优惠活动的顺序图</div>

![](https://s2.ax1x.com/2019/06/05/VNXr8A.png)

<div style="text-align: center">图17 获取所有优惠活动的顺序图</div>

![](https://s2.ax1x.com/2019/06/05/VNXcKP.png)

<div style="text-align: center">图18 删除优惠活动的顺序图</div>

![](https://s2.ax1x.com/2019/06/05/VNXsgI.png)

<div style="text-align: center">图19 获取优惠活动的顺序图</div>

由于ActivityBL只作为工具进行业务逻辑处理，不持有成员变量，因而在处理过程中是无状态的。

(5) 业务逻辑层的设计原理

利用SpringBoot的依赖注入，通过数据层接口获得po后，进行业务逻辑处理，将需要在页面上显示的信息封装成vo，最后封装成ResponseVO返回给上层。

#### 4.1.6 cardbl模块

(1) 模块概述

cardbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

cardbl模块的职责及接口参见软件体系结构文档表x。

(2) 整体结构

根据体系结构的设计，我们将系统分为展示层、控制层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如业务逻辑层和数据层之间，我们添加carddataservice.CardDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了控制层的CardController，这样CardController会将操作优惠活动相关的逻辑处理委托给ActivityBL。

cardbl模块的设计如图20所示。

![](https://s2.ax1x.com/2019/06/05/VNXh5Q.png)

<div style="text-align: center">图20 cardbl模块各个类的设计</div>

cardbl模块各个类的职责如表13所示。

<div style="text-align: center">表13 cardbl模块各个类的职责</div>

|    模块    |             职责             |
| :--------: | :--------------------------: |
| CardTypeBL | 负责实现操作会员卡类型的服务 |
| VIPCardBL  | 负责实现操作用户会员卡的服务 |

(3) 模块内部类的接口规范

CardTypeBL和VIPCardBL的接口规范如表14~15所示。

<div>
    <table>
        <caption><strong>表14 CardTypeBL的接口规范</strong><caption>
        <hr/>
        <caption><strong>提供的服务（供接口）</strong></caption>
        <tr>
            <td rowspan="4">CardTypeBL.getCards</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO getCards()</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>获取所有会员卡类型</td>
        </tr>
        <tr>
            <td rowspan="4">CardTypeBL.publishCard</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO publishCard(CardTypeForm cardTypeForm)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>cardTypeForm信息格式正确</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>发布会员卡类型</td>
        </tr>
        <tr>
            <td rowspan="4">CardTypeBL.deleteCard</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO deleteCard(int cardId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>cardId格式正确</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>删除会员卡类型</td>
        </tr>
        <tr>
            <td rowspan="4">CardTypeBL.updateCard</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO updateCard(int cardId, CardTypeForm cardTypeForm)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>cardId和cardTypeForm格式正确</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>更新会员卡类型信息</td>
        </tr>
    </table>
<div>
<div>
    <table>
        <caption><strong>需要的服务（需接口）</strong><caption>
        <tr>
            <td style="font-weight:bold">服务名</td>
            <td style="font-weight:bold">服务</td>
        </tr>
        <tr>
            <td>CardTypeDataService.selectAllCards()</td>
            <td>获取所有会员卡类型</td>
        </tr>
        <tr>
            <td>CardTypeDataService.insertOneCard(CardType cardType)</td>
            <td>在数据库中插入会员卡类型</td>
        </tr>
        <tr>
            <td>CardTypeDataService.deleteCardById(int cardId)</td>
            <td>在数据库中删除会员卡类型，将会员卡类型状态设为0</td>
        </tr>
        <tr>
            <td>CardTypeDataService.updateCardById(int cardId, CardType cardType)</td>
            <td>更新会员卡类型信息</td>
        </tr>
    </table>
</div>

<div>
    <table>
        <caption><strong>表15 VIPCardBL的接口规范</strong><caption>
        <hr/>
        <caption><strong>提供的服务（供接口）</strong></caption>
        <tr>
            <td rowspan="4">VIPCardBL.addVIPCard</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO addVIPCard(int userId, int cardTypeId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>userId和cardTypeId格式正确</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>为指定用户增加会员卡</td>
        </tr>
        <tr>
            <td rowspan="4">VIPCardBL.getCardByUserId</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO getCardByUserId(int userId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>userId格式正确</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>获取某用户的有效会员卡</td>
        </tr>
        <tr>
            <td rowspan="4">VIPCardBL.charge</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO charge(VIPCardForm vipCardForm)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>vipCardForm格式正确</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>为指定会员卡充值制定金额</td>
        </tr>
        <tr>
            <td rowspan="4">VIPCardBL.changeVIPCard</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO changeVIPCard(int cardId, int cardTypeId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>cardId和carTypeId格式真确</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>更换指定用户的会员卡类型</td>
        </tr>
    </table>
<div>
<div>
    <table>
        <caption><strong>需要的服务（需接口）</strong><caption>
        <tr>
            <td style="font-weight:bold">服务名</td>
            <td style="font-weight:bold">服务</td>
        </tr>
        <tr>
            <td>VIPCardDataService.insertOneCard(VIPCard vipCard)</td>
            <td>为指定用户增加会员卡</td>
        </tr>
        <tr>
            <td>VIPCardDataService.selectCardByUserId(int userId)</td>
            <td>获取某用户的有效会员卡</td>
        </tr>
        <tr>
            <td>VIPCardDataService.updateCardBalance(int id, double balance)</td>
            <td>为指定会员卡更新余额</td>
        </tr>
        <tr>
            <td>VIPCardDataService.selectCardById(int id)</td>
            <td>获取指定id的会员卡</td>
        </tr>
        <tr>
            <td>VIPCardDataService.deleteCardById(int cardId)</td>
            <td>从数据库中删除指定id的会员卡，将状态设置为0</td>
        </tr>
    </table>
</div>




(4) 业务逻辑层的动态模型

图21~24是影院管理系统中CardTypeBL进行业务逻辑处理时的顺序图。

![](https://s2.ax1x.com/2019/06/05/VNXXaF.png)

<div style="text-align: center">图21 获取所有会员卡类型的顺序图</div>

![](https://s2.ax1x.com/2019/06/05/VNXzG9.png)

<div style="text-align: center">图22 发布会员卡类型的顺序图</div>

![](https://s2.ax1x.com/2019/06/05/VNjpx1.png)

<div style="text-align: center">图23 删除会员卡类型的顺序图</div>

![](https://s2.ax1x.com/2019/06/05/VNjPr6.png)

<div style="text-align: center">图24 更新会员卡类型的顺序图</div>

由于CardTypeBL只作为工具进行业务逻辑处理，不持有成员变量，因而在处理过程中是无状态的。



图25~28是影院管理系统中VIPCardBL进行业务逻辑处理时的顺序图。

![](https://s2.ax1x.com/2019/06/05/VNj8Ig.png)

<div style="text-align: center">图25 为用户增加会员卡的顺序图</div>

![](https://s2.ax1x.com/2019/06/05/VNjJiQ.png)

<div style="text-align: center">图26 获取用户会员卡的顺序图</div>

![](https://s2.ax1x.com/2019/06/05/VNjaMq.png)

<div style="text-align: center">图27 充值会员卡的顺序图</div>

![](https://s2.ax1x.com/2019/06/05/VNjDdU.png)

<div style="text-align: center">图28 更换会员卡的顺序图</div>

由于VIPCardBL只作为工具进行业务逻辑处理，不持有成员变量，因而在处理过程中是无状态的。

(5) 业务逻辑层的设计原理

利用SpringBoot的依赖注入，通过数据层接口获得po后，进行业务逻辑处理，将需要在页面上显示的信息封装成vo，最后封装成ResponseVO返回给上层。

#### 4.1.7 couponbl模块

(1) 模块概述

couponbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

couponbl模块的职责及接口参见软件体系结构文档表x。

(2) 整体结构

根据体系结构的设计，我们将系统分为展示层、控制层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如业务逻辑层和数据层之间，我们添加coupondataservice.CouponDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了控制层的CouponController，这样CouponController会将操作优惠活动相关的逻辑处理委托给CouponBL。

couponbl模块的设计如图29所示。

![](https://s2.ax1x.com/2019/06/05/VNjzTS.png)

<div style="text-align: center">图29 couponbl模块各个类的设计</div>

couponbl模块各个类的职责如表16所示。

<div style="text-align: center">表16 couponbl模块各个类的职责</div>

|   模块   |           职责           |
| :------: | :----------------------: |
| CouponBL | 负责实现操作优惠券的服务 |

(3) 模块内部类的接口规范

CouponBL的接口规范如表17所示。

<div>
    <table>
        <caption><strong>表17 CouponBL的接口规范</strong><caption>
        <hr/>
        <caption><strong>提供的服务（供接口）</strong></caption>
        <tr>
            <td rowspan="4"> CouponBL.getAllCoupons </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO getAllCoupons()</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>管理员准备赠送优惠券</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>获取所有优惠券</td>
        </tr>
        <tr>
            <td rowspan="4"> CouponBL.getUsersByConsume </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO getUsersByConsume(double totalConsume)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>totalConsume符合输入规范</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>获取满足一定消费总额的用户</td>
        </tr>
        <tr>
            <td rowspan="4"> CouponBL.presentCoupon2User </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO presentCoupon2User(PresentForm presentForm)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>presentForm符合输入规范</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>批量赠送优惠券</td>
        </tr>
        <tr>
            <td rowspan="4"> CouponBL.getCouponsByUser </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO getCouponsByUser(int userId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>userId存在</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>返回用户拥有的有效优惠券</td>
        </tr>
        <tr>
            <td rowspan="4"> CouponBL.addCoupon </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO addCoupon(CouponForm couponForm)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>couponForm符合输入规范</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>发布新优惠券</td>
        </tr>
    </table>
<div>
<div>
    <table>
        <caption><strong>需要的服务（需接口）</strong><caption>
        <tr>
            <td style="font-weight:bold">服务名</td>
            <td style="font-weight:bold">服务</td>
        </tr>
        <tr>
            <td>ConsumeBL.getConsumeQualifiedUsers(double totalConsume)</td>
            <td>获取满足一定消费总额的用户</td>
        </tr>
        <tr>
            <td>CouponDataService.selectAllCoupons()</td>
            <td>获取所有有效优惠券</td>
        </tr>
        <tr>
            <td>CouponDataService.insertCouponUser(int couponId,int userId)</td>
            <td>赠送某种优惠券给某个用户</td>
        </tr>
        <tr>
            <td>CouponDataService.insertCoupon(Coupon coupon)</td>
            <td>在数据库中插入优惠券</td>
        </tr>
        <tr>
            <td>CouponDataService.selectCouponByUser(int userId)</td>
            <td>获取用户拥有的所有有效优惠券</td>
        </tr>
    </table>
</div>



(4) 业务逻辑层的动态模型

图30~34是影院管理系统中CouponBL进行业务逻辑处理时的顺序图。

![](https://s2.ax1x.com/2019/06/05/VNvCWj.png)

<div style="text-align: center">图30 获取所有优惠券的顺序图</div>

![](https://s2.ax1x.com/2019/06/05/VNviSs.png)

<div style="text-align: center">图31 获取消费满一定金额的用户的顺序图</div>

![](https://s2.ax1x.com/2019/06/05/VNvAO0.png)

<div style="text-align: center">图32 赠送优惠券给用户的顺序图</div>

![](https://s2.ax1x.com/2019/06/05/VNvZwT.png)

<div style="text-align: center">图33 获取用户优惠券的顺序图</div>

![](https://s2.ax1x.com/2019/06/05/VNvnkF.png)

<div style="text-align: center">图34 添加优惠券的顺序图</div>

由于CouponBL只作为工具进行业务逻辑处理，不持有成员变量，因而在处理过程中是无状态的。

(5) 业务逻辑层的设计原理

利用SpringBoot的依赖注入，通过数据层接口获得po后，进行业务逻辑处理，将需要在页面上显示的信息封装成vo，最后封装成ResponseVO返回给上层。

#### 4.1.8 hallbl模块

(1) 模块概述

hallbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

(2) 整体结构

根据体系结构的设计，我们将系统分为展示层、控制层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如业务逻辑层和数据层之间，我们添加halldataservice.HallDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了控制层的HallController，这样HallController会将操作影厅信息相关的逻辑处理委托给HallBL。

hallbl模块的设计如图35所示。

![](https://i.loli.net/2019/06/17/5d077a553bb5287671.jpg)

<div style="text-align: center">图35 hallbl模块各个类的职责</div>

|  模块  |              职责              |
| :----: | :----------------------------: |
| HallBL | 负责实现影厅信息增删改查的服务 |

(3) 模块内部类的接口规范

HallBL的接口规范如表18所示。

<div>
    <table>
        <caption><strong>表18 hallbl模块的接口规范</strong><caption>
        <hr/>
        <caption><strong>提供的服务（供接口）</strong><caption>
        <tr>
            <td rowspan="4">HallBLService.searchAllHall</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO searchAllHall()</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>返回所有影厅信息列表</td>
        </tr>
        <tr>
            <td rowspan="4">HallBLService.addHall</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO addHall(HallVO hallVO)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>hallVO不为空且符合输入规则</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据hallId查询是否存在对应的影厅信息记录，如果有则将对应的影厅信息删除，最后返回删除影厅信息的结果</td>
        </tr>
        <tr>
            <td rowspan="4">HallBLService.updateHall</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO updateHall(HallVO hallVO)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>hallVO不为空且符合输入规则</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据hallVO查询是否已经存在相同的hallName，如果没有则将原来对应的影厅信息更新，最后返回更新影厅信息的结果</td>
        </tr>
        <tr>
            <td rowspan="4">HallBLService.removeHall</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO removeHall(int hallId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据hallId查询是否存在对应的影厅信息记录，如果有则将对应的影厅信息删除，最后返回删除影厅信息的结果</td>
        </tr>
        <tr>
            <td rowspan="4">HallBLService.getAvailableHalls</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO getAvailableHalls()</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>获取所有空闲（没有排片）的影厅信息列表</td>
        </tr>
    </table>
<div>
<div>
    <table>
        <caption><strong>需要的服务（需接口）</strong></caption>
        <tr>
            <td><strong>服务名</strong></td>
            <td><strong>服务</strong></td>
        </tr>
        <tr>
            <td>HallDataService.selectAllHall</td>
            <td>获取所有影厅信息列表</td>
        </tr>
        <tr>
            <td>HallDataService.checkHallName</td>
            <td>查询是否存在相同名字的影厅记录</td>
        </tr>
        <tr>
            <td>HallDataService.addHall</td>
            <td>添加影厅信息</td>
        </tr>
        <tr>
            <td>HallDataService.updateHall</td>
            <td>更新影厅信息</td>
        </tr>
        <tr>
            <td>HallDataService.removeHallById</td>
            <td>根据影厅id删除影厅信息</td>
        </tr>
        <tr>
            <td>HallDataService.getHallsExcept</td>
            <td>根据影厅id列表，获取影厅id不属于该id列表的影厅信息列表</td>
        </tr>
        <tr>
            <td>HallDataService.selectHallById</td>
            <td>根据影厅id获取影厅信息</td>
        </tr>
        <tr>
            <td>ScheduleService.getScheduledHalls</td>
            <td>获取当前已经有排片的影厅id列表</td>
        </tr>
    </table>
</div>


(4) 业务逻辑层的动态模型

图36~40是影院管理系统中HallBL进行业务逻辑处理时的顺序图。

![](https://i.loli.net/2019/06/13/5d0213a2c192e15885.jpg)

<div style="text-align: center">图36 获取所有影厅信息的顺序图</div>

![](https://i.loli.net/2019/06/13/5d0213f52de6496023.jpg)

<div style="text-align: center">图37 添加影厅信息的顺序图</div>

![](https://i.loli.net/2019/06/13/5d0214d5c4c9c69628.jpg)

<div style="text-align: center">图38 删除影厅信息的顺序图</div>

![](https://i.loli.net/2019/06/13/5d02154806c0a42763.jpg)

<div style="text-align: center">图39 更新影厅信息的顺序图</div>

![](https://i.loli.net/2019/06/13/5d02159f8ce6455952.jpg)

<div style="text-align: center">图40 获取空闲的影厅信息的顺序图</div>

由于HallBL只作为工具进行业务逻辑处理，不持有成员变量，因而在处理过程中是无状态的。

(5) 业务逻辑层的设计原理

利用SpringBoot的依赖注入，通过数据层接口获得po后，进行业务逻辑处理，将需要在页面上显示的信息封装成vo，最后封装成ResponseVO返回给上层。

#### 4.1.9 schedulebl模块

(1) 模块概述

schedulebl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

(2) 整体结构

根据体系结构的设计，我们将系统分为展示层、控制层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如业务逻辑层和数据层之间，我们添加scheduledataservice.ScheduleDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了控制层的ScheduleController，这样ScheduleController会将操作影厅信息相关的逻辑处理委托给ScheduleBL。为了方便业务逻辑层其他模块使用排片相关的方法，我们增加了ScheduleServiceForBl，避免层间其他模块直接调用scheduledataservice.ScheduleDataService接口，减少层间的耦合，提高层内内聚

schedulebl模块的设计如图41所示。

![](https://i.loli.net/2019/06/17/5d077a874c74262190.jpg)

<div style="text-align: center">图41 schedulebl模块各个类的职责</div>

|    模块    |        职责        |
| :--------: | :----------------: |
| ScheduleBL | 负责实现排片的服务 |

(3) 模块内部类的接口规范

schedulebl的接口规范如表19所示。

<div>
    <table>
        <caption><strong>表19 schedulebl模块的接口规范</strong><caption>
        <hr/>
        <caption><strong>提供的服务（供接口）</strong><caption>
        <tr>
            <td rowspan="4">ScheduleServiceForBl.getScheduledHalls</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public List&lt;Integer> getScheduledHalls()</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>返回所有已排片的影厅信息列表</td>
        </tr>
    </table>
<div>
    <div>
    <table>
        <caption><strong>需要的服务（需接口）</strong></caption>
        <tr>
            <td><strong>服务名</strong></td>
            <td><strong>服务</strong></td>
        </tr>
        <tr>
            <td>ScheduleDataService.getHallsInSchedules</td>
            <td>获取数据库中当前没有排片（当前时间晚于电影结束时间）的所有影厅id列表</td>
        </tr>
    </table>
</div>



(4) 业务逻辑层的动态模型

图42是影院管理系统中ScheduleBL进行业务逻辑处理时的顺序图。

![](https://i.loli.net/2019/06/13/5d0233b9b41c178788.jpg)

<div style="text-align: center">图42 获取空闲的影厅信息的顺序图</div>

由于ScheduleBL只作为工具进行业务逻辑处理，不持有成员变量，因而在处理过程中是无状态的。

(5) 业务逻辑层的设计原理

利用SpringBoot的依赖注入，通过数据层接口获得po后，进行业务逻辑处理，将需要在页面上显示的信息封装成vo，最后封装成ResponseVO返回给上层。

## 5. 依赖视角

图43和图44是第三阶段客户端和服务器各自的包之间的依赖关系。

![](https://s2.ax1x.com/2019/06/17/VbecKU.png)

<div style="text-align: center">图43 客户端包图</div>

![](https://s2.ax1x.com/2019/06/17/VbZvcT.png)

<div style="text-align: center">图44 服务器端包图</div>