# 影院管理系统（CMS）软件详细设计描述文档

## 文档修改历史

| 修改人员 |   日期    |      修改原因      |   版本号   |
| :------: | :-------: | :----------------: | :--------: |
| Agent_67 | 2019.6.2 | 初始化 | v0.0 |

## 1. 引言

### 1.1 编制目的

本报告详细完成对连续商店管理系统的详细设计，达到指导后续...

### 1.2 词汇表

| 词汇名称 | 词汇含义 | 备注 |
| :-: | :-: | :-: |
| MSCS | 连锁商店管理系统 | …… |
| …… | …… | …… |

### 1.3 参考资料

## 2. 产品描述

参考连锁商店管理系统用例文档和...

## 3. 系统结构设计概述

参考连锁商店管理系统...

## 4. 结构视角

### 4.1 业务逻辑层的分解

业务逻辑层的开发包图参见软件体系结构文档图

#### 4.1.1 userbl模块

(1) 模块概述

userbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

userbl模块的职责及接口参见软件体系结构文档表10。

(2) 整体结构

根据体系结构的设计，我们将系统分为展示层、控制层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如业务逻辑层和数据层之间，我们添加userdataservice.UserDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了控制层的UserController，这样UserController会将对用户登录注册登出的逻辑处理委托给UserBL。

userbl模块的设计如图1所示。

![](https://i.loli.net/2019/06/02/5cf37a8018df184914.png)

<div style="text-align: center">图1 userbl模块各个类的设计</div>

userbl模块各个类的职责如表1所示。

<div style="text-align: center">表1 userbl模块各个类的职责</div>

|  模块  |              职责              |
| :----: | :----------------------------: |
| AccountService | 负责实现用户登录注册登出的服务 |
| RoleService | 负责实现影院角色的添加修改删除的服务 |

(3) 模块内部类的接口规范

AccountService的接口规范如表2所示。

<div>
    <table>
        <caption><strong>表2 AccountService模块的接口规范</strong><caption>
        <hr/>
        <caption><strong>提供的服务（供接口）</strong><caption>
        <tr>
            <td rowspan="4"> AccountService.login </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public User login(UserForm userForm)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>userName符合输入条件</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据username查找是否存在相应的User，如果username和password相匹配，则建立session会话，最后返回登录验证的结果</td>
        </tr>
        <tr>
            <td rowspan="4"> AccountService.registerAccount </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO registerAccount(UserForm userForm)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>userFrom符合输入条件</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据UserForm查找是否已经存在对应的username，如果没有，则增加一条新的用户账号记录，最后返回注册的结果</td>
        </tr>
        <tr>
            <td rowspan="4"> AccountService.checkPassword </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO checkPassword(User user, String rawPassword)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>rawPassword符合输入条件</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据用户输入的密码返回验证结果</td>
        </tr>
        <tr>
            <td rowspan="4"> AccountService.editPassword </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO editPassword(UserForm userForm)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>用户账号存在</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据userForm查找用户的账号并修改账号密码，返回修改的结果</td>
        </tr>
    </table>
<div>

<div>
    <table>
        <caption><strong>需要的服务（需接口）</strong></caption>
        <tr>
            <td><strong>服务名</strong></td>
            <td><strong>服务</strong></td>
        </tr>
        <tr>
            <td>AccountMapper.createNewAccount(String username, String password, Integer auth)</td>
            <td>注册账号</td>
        </tr>
        <tr>
            <td>AccountMapper.getAccountByName( String username)</td>
            <td>根据用户名查找账号</td>
        </tr>
        <tr>
            <td>AccountMapper.updatePassword(UserForm userForm)</td>
            <td>修改密码</td>
        </tr>
    </table>
</div>

RoleService的接口规范如表3所示。

<div>
    <table>
        <caption><strong>表3 RoleService模块的接口规范</strong><caption>
        <hr/>
        <caption><strong>提供的服务（供接口）</strong><caption>
        <tr>
            <td rowspan="4"> RoleService.getAdaptableRoles </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO getAdaptableRoles(Integer level)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>输入的等级是有效等级</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>如果等级是有效的，根据等级查找并返回该等级可修改的影院角色</td>
        </tr>
        <tr>
            <td rowspan="4"> RoleService.deleteRole </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO deleteRole(Integer id)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>id符合输入条件</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>如果该id是有效的，根据id查找并删除该影院角色，返回删除结果</td>
        </tr>
        <tr>
            <td rowspan="4"> RoleService.editRole </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO editRole(RoleVO form)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>from符合输入条件</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>修改影院角色并返回修改结果</td>
        </tr>
        <tr>
            <td rowspan="4"> RoleService.addRole </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO addRole(RoleVO form)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>from符合输入条件</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据from添加影院角色，并返回添加结果</td>
        </tr>
    </table>
<div>

<div>
    <table>
        <caption><strong>需要的服务（需接口）</strong></caption>
        <tr>
            <td><strong>服务名</strong></td>
            <td><strong>服务</strong></td>
        </tr>
        <tr>
            <td>AccountMapper.getCinemaRoles()</td>
            <td>获取全部影院角色</td>
        </tr>
        <tr>
            <td>AccountMapper.deleteRoleById(Integer id)</td>
            <td>删除影院角色</td>
        </tr>
        <tr>
            <td>AccountMapper.updateRoleById(Integer id, String username,
                       String password, Integer auth)</td>
            <td>更新角色信息</td>
        </tr>
    </table>
</div>
(4) 业务逻辑层的动态模型

(4) 业务逻辑层的动态模型

由于UserBL只作为工具进行业务逻辑处理，不持有成员变量，因而在处理过程中是无状态的。

(5) 业务逻辑层的设计原理

利用SpringBoot的依赖注入，通过数据层接口获得po后，进行业务逻辑处理，最后封装成ResponseVO返回给上层。



#### 4.1.2 salesbl模块

(1) 模块概述
salesbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

salesbl模块的职责及接口参见软件体系结构文档表24。

(2) 整体结构

根据体系结构的设计，我们将系统分为展示层、控制层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如业务逻辑层和数据层之间，我们添加salesdataservice.SalesDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了控制层的SalesController，这样SalesController会将操作优惠活动相关的逻辑处理委托给SalesBL。

salesbl模块的设计如图3所示。

![](https://s2.ax1x.com/2019/06/02/V8H9JO.png)

<div style="text-align: center">图3 salesbl模块各个类的设计</div>

salesbl模块各个类的职责如表4所示。

<div style="text-align: center">表4 salesbl模块各个类的职责</div>

|  模块   |             职责             |
| :-----: | :--------------------------: |
| TicketService |    负责实现操作电影票的服务    |
|  RefundService  | 负责实现退票功能所需要的服务 |

(3) 模块内部类的接口规范
TicketService的接口规范如表5

<div> 
    <table>
        <caption><strong>表5 TicketService模块的接口规范</strong><caption>
        <hr/>
        <caption><strong>提供的服务（供接口）</strong><caption>
        <tr>
            <td rowspan="4"> TicketService.completeByVIPCard </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO completeByVIPCard(List<Integer> id, int couponId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>id不为空</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据ticket查找是否存在相应的会员卡，根据couponId查找是否存在相应的优惠券，存在则完成购买电影票流程，返回购买结果</td>
        </tr>
        <tr>
            <td rowspan="4"> TicketService.addTicket </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO addTicket(TicketForm ticketForm)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>ticketFrom符合条件</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据ticketFrom锁座，返回锁座结果</td>
        </tr>
        <tr>
            <td rowspan="4"> TicketService.completeTicket </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO completeTicket(List<Integer> id, int couponId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>id不为空</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据ticketAndCouponVO查找并购买电影票，并返回购票结果</td>
        </tr>
        <tr>
            <td rowspan="4"> TicketService.getTicketByUser </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO getTicketByUser(int userId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>userId有效</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据userId查找并返回用户买过的电影票</td>
        </tr>
        <tr>
            <td rowspan="4"> TicketService.getBySchedule </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO getBySchedule(int scheduleId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>scheduleId是有效id</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据scheduleId查找并返回该排片的锁座情况</td>
        </tr>
        <tr>
            <td rowspan="4"> TicketService.cancelTicket </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO cancelTicket(List<Integer> id)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>id不为空</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据ticketId查找并删除电影票，返回删除结果</td>
        </tr>
        <tr>
            <td rowspan="4"> TicketService.issueTicket </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO issueTicket(int id)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>id为有效电影票id</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据ticketId查找并修改电影票状态为出票，返回出票结果</td>
        </tr>
    </table>
<div>

<div>
    <table>
        <caption><strong>需要的服务（需接口）</strong></caption>
        <tr>
            <td><strong>服务名</strong></td>
            <td><strong>服务</strong></td>
        </tr>
        <tr>
            <td>TicketMapper.insertTicket(Ticket ticket)</td>
            <td>添加单张电影票</td>
        </tr>
        <tr>
            <td>TicketMapper.insertTickets(List<Ticket> tickets)</td>
            <td>添加多张电影票</td>
        </tr>
        <tr>
            <td>TicketMapper.deleteTicket(int ticketId)</td>
            <td>删除电影票</td>
        </tr>
        <tr>
            <td>TicketMapper.selectTicketByUser(int userId)</td>
            <td>获得用户买过的票</td>
        </tr>
        <tr>
            <td>TicketMapper.deleteLockedTicket(int userId, int scheduleId)</td>
            <td>删除被锁座位的票</td>
        </tr>
        <tr>
            <td>TicketMapper.updateTicketState(int ticketId, int state)</td>
            <td>更新电影票状态</td>
        </tr>
        <tr>
            <td>TicketMapper.updateTicketActualPay(int ticketId, double actualPay)</td>
            <td>更新票的实际支付金额</td>
        </tr>
        <tr>
            <td>TicketMapper.selectTicketsBySchedule(int scheduleId)</td>
            <td>根据排片获取电影票</td>
        </tr>
        <tr>
            <td>TicketMapper.selectTicketByScheduleIdAndSeatint scheduleId, int columnIndex, int rowIndex)</td>
            <td>根据排片和座位获取电影票</td>
        </tr>
        <tr>
            <td>TicketMapper.selectTicketById(int id)</td>
            <td>根据id获取电影票</td>
        </tr>
        <tr>
            <td>ConsumeService.addConsumeHistory(Integer userId, Double money, Double discount, String consumeType, Integer type, Integer contentId)</td>
            <td>添加消费记录</td>
        </tr>
        <tr>
            <td>ScheduleServiceForBl.getScheduleItemById(int id)</td>
            <td>根据id查找排片信息</td>
        </tr>
        <tr>
            <td>HallServiceForBl.getHallById(int id)</td>
            <td>根据id查找影厅</td>
        </tr>
        <tr>
            <td>CouponServiceForBl.getCoupon(int couponId)</td>
            <td>根据id获取优惠券</td>
        </tr>
        <tr>
            <td>CouponServiceForBl.issueCoupon(int couponId,int userId)</td>
            <td>根据userId和couponId新增一条优惠券信息</td>
        </tr>
        <tr>
            <td>CouponServiceForBl.getCouponsByUser(int userId)</td>
            <td>根据userId获取优惠券</td>
        </tr>
        <tr>
            <td>ActivityServiceForBl.getActivitiesByMovie(int movieId)</td>
            <td>根据movieId获取优惠活动</td>
        </tr>
        <tr>
            <td>ActivityServiceForBl.getActivityList()</td>
            <td>获取所有优惠活动</td>
        </tr>
        <tr>
            <td>VIPServiceForBl.getCardByUserId(int userId)</td>
            <td>根据userId获取会员卡</td>
        </tr>
        <tr>
            <td>VIPServiceForBl.payByCard(int id, double balance)</td>
            <td>使用会员卡支付</td>
        </tr>
        <tr>
            <td>RefundServiceForBl.getRefundByMovieId(int movieId)</td>
            <td>根据movieId获取退票策略</td>
        </tr>
    </table>
</div>

RefundService的接口规范如表5

<div>
    <table>
        <caption><strong>表5 RefundService模块的接口规范</strong><caption>
        <hr/>
        <caption><strong>提供的服务（供接口）</strong><caption>
        <tr>
            <td rowspan="4"> RefundService.getAllRefund </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO getAllRefund()</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>获取并返回所有退票策略</td>
        </tr>
        <tr>
            <td rowspan="4"> RefundService.publishRefund </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO publishRefund(RefundForm refundForm)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>refundFrom符合输入条件</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据refundFrom新增一条退票策略，返回新增结果</td>
        </tr>
        <tr>
            <td rowspan="4"> RefundService.deleteRefund </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO deleteRefund(int refundId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>refundId存在</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据refundId查找并删除退票策略，返回删除结果</td>
        </tr>
        <tr>
            <td rowspan="4"> RefundService.getRefundById </td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>public ResponseVO getRefundById(int refundId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>refundId存在</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>根据refundId查找并返回退票策略</td>
        </tr>
    </table>
<div>

<div>
    <table>
        <caption><strong>需要的服务（需接口）</strong></caption>
        <tr>
            <td><strong>服务名</strong></td>
            <td><strong>服务</strong></td>
        </tr>
            <td>RefundMapper.selectRefund()</td>
            <td>获得所有退票策略</td>
        </tr>
        <tr>
            <td>RefundMapper.insertRefund(Refund refund)</td>
            <td>新增退票策略</td>
        </tr>
        <tr>
            <td>RefundMapper.deleteRefundById(int refundId)</td>
            <td>根据id删除一条退票策略</td>
        </tr>
        <tr>
            <td>RefundMapper.selectRefundByMovieId(int movieId)</td>
            <td>根据电影获取退票策略</td>
        </tr>
        <tr>
            <td>RefundMapper.selectRefundById(int refundId)</td>
            <td>根据id获取退票策略</td>
        </tr>
        <tr>
            <td>MovieServiceForBl.getMovieById(int id)</td>
            <td>根据id查找电影</td>
        </tr>
    </table>
</div>

(4) 业务逻辑层的动态模型

由于SalesBL只作为工具进行业务逻辑处理，不持有成员变量，因而在处理过程中是无状态的。

(5) 业务逻辑层的设计原理

利用SpringBoot的依赖注入，通过数据层接口获得po后，进行业务逻辑处理，最后封装成ResponseVO返回给上层。

#### 4.1.X statisticsbl模块

(1)模块概述

statisticsbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

statisticsbl模块的职责及接口参见软件体系结构文档表Y。

(2) 整体结构

根据体系结构的设计，我们将系统分为展示层、控制层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如业务逻辑层和数据层之间，我们添加statisticsdataservice.MovieLikeDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了控制层的StatisticsController，这样StatisticsController会将电影统计数据相关的逻辑处理委托给MovieLikeBL和StatisticsBL。

statisticsbl模块的设计如图XX所示。

![]()

<div style="text-align: center">图XX statisticsbl模块各个类的设计</div>

statisticsbl模块各个类的职责如表XX所示。

<div style="text-align: center">表XX statisticsbl模块各个类的职责</div>

|     模块     |                 职责                 |
| :----------: | :----------------------------------: |
| MovieLikeBL  |      负责实现想看电影相关的服务      |
| StatisticsBL | 负责实现获取电影统计数据所需要的服务 |

(3) 模块内部类的接口规范

MovieLikeBL和StatisticsBL的接口规范如表XX~XX所示。

<div>
    <table>
        <caption><strong>表x MovieLikeBL模块的接口规范</strong><caption>
        <hr/>
        <caption><strong>提供的服务（供接口）</strong><caption>
        <tr>
            <td rowspan="4">MovieLikeBL.likeMovie</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>ResponseVO likeMovie(int userId, int movieId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>标记电影为想看</td>
        </tr>
        <tr>
            <td rowspan="4">MovieLikeBL.unLikeMovie</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>ResponseVO unlikeMovie(int userId, int movieId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>取消电影为想看</td>
        </tr>
        <tr>
            <td rowspan="4">MovieLikeBL.getCountOfLikes</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>ResponseVO getCountOfLikes(int movieId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>统计想看电影的人数</td>
        </tr>
        <tr>
            <td rowspan="4">MovieLikeBL.getLikeNumsGroupByDate</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>ResponseVO getLikeNumsGroupByDate(int movieId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>获得电影每日的想看人数</td>
        </tr>
    </table>
<div>

<div>
    <table>
        <caption><strong>需要的服务（需接口）</strong></caption>
        <tr>
            <td><strong>服务名</strong></td>
            <td><strong>服务</strong></td>
        </tr>
        <tr>
            <td>MovieLikeDataService.insertOneLike(int movieId,int userId)</td>
            <td>插入一条想看记录</td>
        </tr>
        <tr>
        	<td>MovieLikeDataService.deleteOneLike(int movieId,int userId)</td>
            <td>删除一条想看记录</td>
        </tr>
         <tr>
        	<td>MovieLikeDataService.selectLikeNums(int movieId)</td>
            <td>根据movieId查看电影的想看人数</td>
        </tr>
         <tr>
        	<td>MovieLikeDataService.selectLikeMovie(int movieId,int userId)</td>
            <td>根据movieId和userId查找特定想看记录</td>
        </tr>
         <tr>
        	<td>MovieLikeDataService.selectMovieScheduleTimes(Date date, Date nextDate)</td>
            <td>查询date当天每部电影的排片次数</td>
        </tr>
        <tr>
        	<td>MovieLikeDataService.getDateLikeNum(int movieId)</td>
            <td>根据movieId获取按日期统计的想看人数</td>
        </tr>
    </table>
</div>

<div>
    <table>
        <caption><strong>表x StatisticsBL模块的接口规范</strong><caption>
        <hr/>
        <caption><strong>提供的服务（供接口）</strong><caption>
        <tr>
            <td rowspan="4">StatisticsBL.getScheduleRateByDate</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>ResponseVO getScheduleRateByDate(Date date)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>获取某日各影片排片率统计数据</td>
        </tr>
        <tr>
            <td rowspan="4">StatisticsBL.getTotalBoxOffice</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>ResponseVO getTotalBoxOffice()</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>获取所有电影的累计票房(降序排序，且包含已下架的电影)</td>
        </tr>
        <tr>
            <td rowspan="4">StatisticsBL.getAudiencePriceSevenDays</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>ResponseVO getAudiencePriceSevenDays()</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>获得过去7天内每天客单价</td>
        </tr>
        <tr>
            <td rowspan="4">StatisticsBL.getMoviePlacingRateByDate</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>ResponseVO getMoviePlacingRateByDate(Date date)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>获取所有电影某天的上座率</td>
        </tr>
        <tr>
            <td rowspan="4">StatisticsBL.getPopularMovies</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>ResponseVO getPopularMovies(int days, int movieNum)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>获取最近days天内，票房最高的的movieNum个电影</td>
        </tr>
    </table>
<div>

<div>
    <table>
        <caption><strong>需要的服务（需接口）</strong></caption>
        <tr>
            <td><strong>服务名</strong></td>
            <td><strong>服务</strong></td>
        </tr>
         <tr>
        	<td>StatisticsDataService.selectMovieScheduleTimes(Date date, Date nextDate)</td>
            <td>查询date当天每部电影的排片次数</td>
        </tr>
        <tr>
        	<td>StatisticsDataService.getDateLikeNum(int movieId)</td>
            <td>根据movieId获取按日期统计的想看人数</td>
        </tr>
        <tr>
        	<td>StatisticsDataService.selectMovieTotalBoxOffice()</td>
            <td>查询所有电影的总票房（包括已经下架的，降序排列）</td>
        </tr>
        <tr>
        	<td>StatisticsDataService.selectAudiencePrice(Date date,Date nextDate)</td>
            <td>查询date当天每个客户的购票金额</td>
        </tr>
        <tr>
        	<td>StatisticsDataService.selectPlacingRate(Date date,Date nextDate)</td>
            <td>查询date当天各电影上座率</td>
        </tr>
        <tr>
        	<td>StatisticsDataService.selectRecentTotalBoxOffice(Date startDate,Date today,int num)</td>
            <td>查询startDate到today日期内票房最高的num部电影</td>
        </tr>
    </table>
</div>

(4) 业务逻辑层的动态模型

图XX~XX是影院管理系统中StatisticsBL进行业务逻辑处理时的顺序图。

![]()

![]()

由于MovieLikeBL和StatisticsBL只作为工具进行业务逻辑处理，不持有成员变量，因而在处理过程中是无状态的。

(5) 业务逻辑层的设计原理

利用SpringBoot的依赖注入，通过数据层接口获得po后，进行业务逻辑处理，将需要在页面上显示的信息封装成vo，最后封装成ResponseVO返回给上层。

#### 4.1.X consumebl模块

(1)模块概述

consumebl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

consumebl模块的职责及接口参见软件体系结构文档表Y。

(2) 整体结构

根据体系结构的设计，我们将系统分为展示层、控制层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如业务逻辑层和数据层之间，我们添加consumedataservice.ConsumeDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了控制层的ConsumeController，这样ConsumeController会将电影统计数据相关的逻辑处理委托给ConsumeBL。

consumebl模块的设计如图XX所示。

![]()

<div style="text-align: center">图XX consumebl模块各个类的设计</div>

consumebl模块各个类的职责如表XX所示。

<div style="text-align: center">表XXconsumebl模块各个类的职责</div>

|   模块    |              职责              |
| :-------: | :----------------------------: |
| ConsumeBL | 负责实现充值消费记录相关的服务 |

(3) 模块内部类的接口规范

ConsumeBL的接口规范如表XX所示。

<div>
    <table>
        <caption><strong>表x ConsumeBL模块的接口规范</strong><caption>
        <hr/>
        <caption><strong>提供的服务（供接口）</strong><caption>
        <tr>
            <td rowspan="4">ConSumeBL.getAllTopUpHistory</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>ResponseVO getAllTopUpHistory(Integer userId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>获取用户全部的充值记录</td>
        </tr>
        <tr>
            <td rowspan="4">ConSumeBL.getBriefConsumeHis</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>ResponseVO getBriefConsumeHis(Integer userId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>获取用户简略消费记录信息</td>
        </tr>
        <tr>
            <td rowspan="4">ConSumeBL.getConsumeHisDetail</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>ResponseVO getConsumeHisDetail(Integer id)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>获取用户消费记录详细信息</td>
        </tr>
        <tr>
            <td rowspan="4">ConSumeBL.addTopUpHistory</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>ResponseVO addTopUpHistory(Integer userId, Double money, Double discount, Double balance, Timestamp time)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>添加充值记录</td>
        </tr>
        <tr>
            <td rowspan="4">ConSumeBL.addConsumeHistory</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>ResponseVO addConsumeHistory(Integer userId, Double money, Double discount, String consumeType,Integer type, Integer contentId)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>添加消费记录</td>
        </tr>
        <tr>
            <td rowspan="4">ConSumeBL.getConsumeQualifiedUsers</td>
        </tr>
        <tr>
            <td><strong>语法</strong></td>
            <td>ResponseVO getConsumeQualifiedUsers(Double totalConsume)</td>
        </tr>
        <tr>
            <td><strong>前置条件</strong></td>
            <td>无</td>
        </tr>
        <tr>
            <td><strong>后置条件</strong></td>
            <td>获取消费总额满一定值的用户信息</td>
        </tr>
    </table>
<div>
<div>
    <table>
        <caption><strong>需要的服务（需接口）</strong></caption>
        <tr>
            <td><strong>服务名</strong></td>
            <td><strong>服务</strong></td>
        </tr>
        <tr>
            <td>ConsumeDateService.getTopUpHistoryByUserId(Integer userId)</td>
            <td>根据userId获取此用户的充值记录列表，若无记录则返回空</td>
        </tr>
        <tr>
        	<td>ConsumeDateService.getConsumeHistoryByUserId(Integer userId)</td>
            <td>根据userId获取此用户的消费记录列表，若无记录则返回空</td>
        </tr>
         <tr>
        	<td>ConsumeDateService.getConsumeHistoryById(Integer id)</td>
            <td>根据id获取消费记录</td>
        </tr>
         <tr>
        	<td>ConsumeDateService.insertTopUpHistory(Integer userId, Double money,Double discount,Double balance,Timestamp time)</td>
            <td>插入新的充值记录</td>
        </tr>
         <tr>
        	<td>ConsumeDateService.insertConsumeHistory(Integer userId, Double money,Double discount,String consumeType,Integer type,Integer contentId)</td>
            <td>插入新的消费记录</td>
        </tr>
        <tr>
        	<td>ConsumeDateService.selectConsumeQulifiedUsers(Double totalConsume)</td>
            <td>获得消费总额大于totalConsume的用户</td>
        </tr>
        <tr>
        	<td>HallServiceForBl.getHallById(int id)</td>
            <td>获得指定影厅信息</td>
        </tr>
        <tr>
        	<td>MovieServiceForBl.getMovieById(int id)</td>
            <td>获得指定电影信息</td>
        </tr>
        <tr>
        	<td>ScheduleServiceForBl.getScheduleItemById(int id)</td>
            <td>获得指定排片信息</td>
        </tr>
        <tr>
        	<td>VipService.getCardById(int id)</td>
            <td>获得指定会员卡信息</td>
        </tr>
        <tr>
        	<td>TicketServiceForBl.getTicketById(int id)</td>
            <td>获得指定电影票信息</td>
        </tr>
    </table>
</div>

(4) 业务逻辑层的动态模型

图XX~XX是影院管理系统中ConsumeBL进行业务逻辑处理时的顺序图。

![]()

![]()

由于ConsumeBL只作为工具进行业务逻辑处理，不持有成员变量，因而在处理过程中是无状态的。

(5) 业务逻辑层的设计原理

利用SpringBoot的依赖注入，通过数据层接口获得po后，进行业务逻辑处理，将需要在页面上显示的信息封装成vo，最后封装成ResponseVO返回给上层。

## 5. 依赖视角

